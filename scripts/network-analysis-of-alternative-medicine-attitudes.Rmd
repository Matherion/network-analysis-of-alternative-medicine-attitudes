---
title: "Network analysis of alternative medicine attitudes"
author: "Szilvia Zörgő, Samvel Mkhitaryan & Gjalt-Jorn Peters"
date: "`r format(Sys.Date())`"
html_document:
  self_contained: true
editor_options: 
  chunk_output_type: console
---

# Introduction

This file is a part of the Open Science Framework repository at https://osf.io/djkyf/. A rendered version of this R Markdown file is normally available at [this GitHub HTML Preview service page](https://htmlpreview.github.io/?https://github.com/Matherion/network-analysis-of-alternative-medicine-attitudes/blob/master/scripts/network-analysis-of-alternative-medicine-attitudes.html).

Note that in that preview, the 'tabbed layout' that makes, for example, userfriendly inspection of the pairwise scatterplots possible, does not work (perhaps GitHub Preview blocks javascript?), so you may want to download the rendered .html in any case.

# Analyses

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE);

if (!'ufs' %in% row.names(installed.packages())) install.packages('ufs');
ufs::safeRequire('haven');
ufs::safeRequire('here');
ufs::safeRequire('pander');
ufs::safeRequire('GGally');
ufs::safeRequire('ggcorrplot');
ufs::safeRequire('userfriendlyscience');
ufs::safeRequire('tidyr')
ufs::safeRequire('qgraph')
ufs::safeRequire('bootnet')
ufs::safeRequire('igraph')
ufs::safeRequire('corpcor')
ufs::safeRequire('NetworkComparisonTest')
ufs::safeRequire('EstimateGroupNetwork')

### Get dev versions of some packages
devtools::install_gitlab("r-packages/ufs");
devtools::install_gitlab("r-packages/yum");

dataPath <-
  here::here('data');

```

## Loading and preparing data

```{r import-data}

### Import using haven
dat <-
  haven::read_sav(file.path(dataPath,
                            'database.orig.new labels.sav'));

### ... But convert to a data frame instead of a tibble, because,
### for example, length(unique(dat[, 'group'])) results in 1 instead
### of 2...
dat <- as.data.frame(dat);
dat <- haven::zap_label(dat);
dat <- haven::zap_labels(dat);

### Set group as factor
dat$group <-
  factor(dat$group,
         levels=1:2,
         labels=c("Alternative medicine",
                  "Medicine"));

dat$group_tri <-
  ifelse(dat$group=="Medicine",
         1,
         ifelse(dat$TCM6_simult < 3,
                2,
                ifelse(dat$TCM6_simult > 2,
                       3,
                       NA)));

dat$group_tri <-
  factor(dat$group_tri,
         levels=1:3,
         labels=c("Biomed",
                  "Alternative",
                  "Complementary"));
         
### Extract and store attitude variable names
attitudeVars <-
  grep('ATT1_',
       names(dat),
       value=TRUE);

attitudeVars_2 <-
  grep('ATT2_',
       names(dat),
       value=TRUE);

```

## Construct tree of attitude items

```{r construct-tree}

constructTreeYAML <-
  yum::load_yaml_fragments(here::here("methods-construct-tree",
                                      "cam-biomed-attitude-tree-1.dct"));

constructTree <-
  yum::build_tree(constructTreeYAML);

### Set labels as names
constructTree$Do(function(node) node$name <- node$label);

### Convert to DiagrammeR graph
constructGraph <-
  data.tree::ToDiagrammeRGraph(constructTree);

### Show graph
DiagrammeR::render_graph(constructGraph);

### Export graph
DiagrammeR::export_graph(constructGraph,
                         file_name = here::here("methods-construct-tree",
                                                "cam-biomed-attitude-tree-1.png"));

### Also plot as dendrogram (method not exported by this version of data.tree, oddly)
plot(data.tree:::as.dendrogram.Node(constructTree));

```

## Descriptives

```{r descriptives, fig.height=20, results="asis"}

ufs::cat0("\n\n### Group\n\n");
pander(userfriendlyscience::freq(dat$group));

ufs::cat0("\n\n### Missing values\n\n");
apply(is.na(dat[, attitudeVars]), 2, sum);

ufs::cat0("\n\n### Attitude\n\n");
ufs::meansComparisonDiamondPlot(dat,
                                rev(attitudeVars),
                                compareBy = 'group_tri',
                                comparisonColors = viridis::viridis(3,
                                                                    end=.7),
                                dataAlpha=.25);

```

## Correlations {.tabset .tabset-fade}

### All attitude variables together

```{r correlations-all, fig.width=18, fig.height=18}

### Takes way too long, huge, etc
# GGally::ggpairs(dat[, attitudeVars]);

cors <- cor(dat[, attitudeVars],
            use='complete.obs');

knitr::kable(cors);

### http://www.sthda.com/english/wiki/ggcorrplot-visualization-of-a-correlation-matrix-using-ggplot2
                
ggcorrplot::ggcorrplot(cors);

ggcorrplot::ggcorrplot(cors,
                       method = "circle");

ggcorrplot(cors,
           hc.order = TRUE,
           outline.col = "white")

ggcorrplot::ggcorrplot(cors,
                       lab = TRUE);

```

### Pairwise scatterplots {.tabset .tabset-fade .tabset-pills}

```{r correlations-pairwise, fig.width=6, fig.height=6, results="asis", eval=FALSE}

for (xAxisVar in attitudeVars) {

  ufs::cat0("\n\n#### ", xAxisVar,
            " {.tabset .tabset-fade .tabset-pills}\n\n");

  for (yAxisVar in tail(attitudeVars, -1)) {

    ### Only for 'half the matrix'
    if (which(attitudeVars == yAxisVar) >
        which(attitudeVars == xAxisVar)) {
      ufs::cat0("\n\n##### ", yAxisVar,
                "\n\n");
      print(ggplot2::ggplot(data=dat,
                            mapping=ggplot2::aes_string(x=xAxisVar,
                                                        y=yAxisVar,
                                                        color='group_tri')) +
              geom_jitter(size=3) +
              theme_minimal());
    }
  }
}

```


## Network analyses

For the network analysis section we will first estimate a full network where a choice of medical practice is regarded as a system component. This will allow us explore how attitudes relate to the behavior of interest and the relative importance of each determinant. Afterwards, we will create sub samples based on a variable that represents groups of people that prefare one or other medical practice. This way we can investigate structural features of networks (topologies) that are peculiar to these groups.

```{r network-analyses, fig.width=6, fig.height=6, results="asis", eval=TRUE}

# here I subset data that is going to be used in the network analysis with the behavior as a component.

subset = dat[, c("sex", "age",
                 "religion", "education",
                 "salary", "family_status",
                 attitudeVars,
                 "group_tri")];

### Here I create subsets based on the grouping variable.
for(i in levels(subset$group_tri)){
  assign(paste("subset",
               i,
               sep = "_"),
         subset(subset,
                subset$group_tri == i))    
}

### Samvel; applied some R 'best practices', see https://style.tidyverse.org/
subset$group_tri <-
  as.numeric(subset$group_tri);

subset <-
  subset %>% tidyr::drop_na();

```

## Step 1: Estimating the netork with full data. 

```{r network-analyses, fig.width=6, fig.height=6, results="asis", eval=TRUE}

network <-
  estimateNetwork(subset[, c(7:47)],
                  default = "EBICglasso");

plot(network,
     layout = 'spring',
     labels = colnames(network),
     title = c('Figure 1: A Network with the behavioral variable'));

# Calculating centrality measures.
centralityPlot(network,
               include = "all");

# Checking the stability of the centrality measures
central_stability <- 
  bootnet(network,
          nBoots = 1000,
          type = 'case');

plot(central_stability)

# Checking the stability/reliability of the edge weights
edgewgt <-
  bootnet(network,
          nBoots = 2500);

plot(edgewgt,
     labels = FALSE,
     order = 'sample');

```

# Exploring shortest paths from each node to the behavior of interest.

```{r network-analyses, fig.width=6, fig.height=6, results="asis", eval=TRUE}

## Calculting the shortest paths with Dijkstra's algorithm.

### First we need to take the absoulte values of the adjacency matrix. Then recreate a network object for further analysis.

absolute_adj <-
  abs(network$graph);

graph_full <- 
  graph.adjacency(absolute_adj,
                  mode = 'undirected',
                  weighted = TRUE);

# Calculate shortest path to the outcome variable and then delete the last row of the dataframe that includes the outcome variable (shortest path to itself = 0) 

dijkstra_fullnetwork <-
  igraph::distances(graph_full,
                    v = V(graph_full),
                    to = 26,
                    algorithm = "dijkstra");

dijkstra_ful <-
  subset(dijkstra_fullnetwork,
         dijkstra_fullnetwork[,] == min(dijkstra_fullnetwork[-c(26),]));

# Creating a table with the shortest paths
table_dijkstra <-
  as.table(dijkstra_ful)

print(table_dijkstra)

```


